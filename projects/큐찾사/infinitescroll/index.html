<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Next.js 에서 무한스크롤 및 스크롤 위치 내용 저장하는 2가지 방법 | 채수현 개발일지</title><meta name=keywords content="Next.js,React Query,Infinite Scroll"><meta name=description content="React Query의 InfiniteScroll을 적용하는 방법과 상세페이지에 들어갔다 나올때 스크롤 위치를 저장하는 방법에 대해 소개합니다."><meta name=author content="cha2hyun"><link rel=canonical href=https://cha2hyun.github.io/projects/%ED%81%90%EC%B0%BE%EC%82%AC/infinitescroll/><link crossorigin=anonymous href=/assets/css/stylesheet.e2c4e45c227cff2d0b236143ff7f2e39b6a7f2bd2019a845c0f754cd1b58fa1f.css integrity="sha256-4sTkXCJ8/y0LI2FD/38uOban8r0gGahFwPdUzRtY+h8=" rel="preload stylesheet" as=style><link rel=icon href=https://cha2hyun.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cha2hyun.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cha2hyun.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cha2hyun.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cha2hyun.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Next.js 에서 무한스크롤 및 스크롤 위치 내용 저장하는 2가지 방법"><meta property="og:description" content="React Query의 InfiniteScroll을 적용하는 방법과 상세페이지에 들어갔다 나올때 스크롤 위치를 저장하는 방법에 대해 소개합니다."><meta property="og:type" content="article"><meta property="og:url" content="https://cha2hyun.github.io/projects/%ED%81%90%EC%B0%BE%EC%82%AC/infinitescroll/"><meta property="og:image" content="https://cha2hyun.github.io/papermod-cover.png"><meta property="article:section" content="projects"><meta property="article:published_time" content="2022-11-04T00:00:00+00:00"><meta property="article:modified_time" content="2022-11-04T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cha2hyun.github.io/papermod-cover.png"><meta name=twitter:title content="Next.js 에서 무한스크롤 및 스크롤 위치 내용 저장하는 2가지 방법"><meta name=twitter:description content="React Query의 InfiniteScroll을 적용하는 방법과 상세페이지에 들어갔다 나올때 스크롤 위치를 저장하는 방법에 대해 소개합니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Projects","item":"https://cha2hyun.github.io/projects/"},{"@type":"ListItem","position":3,"name":"Next.js 에서 무한스크롤 및 스크롤 위치 내용 저장하는 2가지 방법","item":"https://cha2hyun.github.io/projects/%ED%81%90%EC%B0%BE%EC%82%AC/infinitescroll/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Next.js 에서 무한스크롤 및 스크롤 위치 내용 저장하는 2가지 방법","name":"Next.js 에서 무한스크롤 및 스크롤 위치 내용 저장하는 2가지 방법","description":"React Query의 InfiniteScroll을 적용하는 방법과 상세페이지에 들어갔다 나올때 스크롤 위치를 저장하는 방법에 대해 소개합니다.","keywords":["Next.js","React Query","Infinite Scroll"],"articleBody":"들어가며 새로운 홈페이지를 기획, 개발하면서 최대한 앱과 동일한 사용자 경험을 주기 위해 고민을 많이 했습니다. 오랫동안 준비했던 apppage_v2의 경우 react로 제작하였으며 일반적인 페지네이션을 이용했습니다. 다만, 일반적인 페지네이션으로는 모바일에서 앱과 같은 경험을 주지 못하는 점이 아쉬워 아예 새롭게 Next.js로 프로젝트를 새로 만들어서 React Query의 infiniteScroll을 도입하였습니다. 준비하며 무한 스크롤을 도입할 때 다음과 같은 내용이 고려되었습니다.\n무한 스크롤이 적용된 리스트를 클릭했을때 어떤 식으로 상세페이지를 제공할 것인가? 상세페이지에서 다시 리스트로 돌아갈때 이미 불러온 데이터를 다시 불러오지 않아야한다. 2번이 적용된다면 다시 리스트로 돌아갈때 스크롤 했던 위치로 돌아가져야한다. 상세페이지 표시 전략 무한 스크롤이 도입될 곳은 내큐찾기와 커뮤니티 였습니다. 다만 두 카테고리는 각자 다른 특성을 가지고 있습니다. 서비스 핵심 모델이 적요되는 내큐찾기에서는 최대한 빠르게 유저에게 로딩되는 경험을 주어야하고, 커뮤니티에서는 댓글, 답글 등의 추가 기능들이 필요했습니다. 따라서 다음과 같이 적용하였습니다.\n내큐찾기\nList에서 Item 클릭 시 Route 이동 없이 Modal 형식으로 제공 List에서 Fetch 시 Modal에서 표시할 내용들은 전부 포함하도록 Api 설계 따라서 Modal에 들어갈때 추가 로딩표시 없이 즉각적으로 보여지게됨 한번 Fetching한 데이터는 캐시에 남겨 로딩할 때도 매우빠른 로딩속도를 제공 각 Item 은 화면에 표시될 때 Fade in 애니메이션을 주어 새롭운 페이지를 Fetching 할때도 자연스럽고 연속적으로 보여지는 것으로 의도 커뮤니티\nList에서 Item 클릭 시 새로운 상세페이지로 이동 이동할때 이때 LocalStoarge에 scrollY 값을 저장 상세페이지에서 다시 리스트로 돌아올 때 scrollY 값으로 스크롤 위치 이동 단, 이때 처음부터 List를 다시 불러온다면 저장된 scrollY 값으로 가질 수 없으므로 (1번 이상 추가로딩이 되었을 경우) 리스트 데이터는 새로 불러오면 안된다. 구현 계속 …\n","wordCount":"230","inLanguage":"en","datePublished":"2022-11-04T00:00:00Z","dateModified":"2022-11-04T00:00:00Z","author":{"@type":"Person","name":"cha2hyun"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cha2hyun.github.io/projects/%ED%81%90%EC%B0%BE%EC%82%AC/infinitescroll/"},"publisher":{"@type":"Organization","name":"채수현 개발일지","logo":{"@type":"ImageObject","url":"https://cha2hyun.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div><div class=logo><a href=https://cha2hyun.github.io/ accesskey=h title="채수현 개발일지 (Alt + H)">채수현 개발일지<span style=justify-content:center>
<img src="https://visitor-badge.glitch.me/badge?page_id=cha2hyun.github.io&left_color=black&right_color=black&left_text=HITS" alt=Views></span></a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><div class=logo style=margin-bottom:-30px;margin-top:-30px;font-size:15px><span>기억은 유한하나, 기록은 무한하다 📚</span></div></div><ul id=menu><li><a href=https://cha2hyun.github.io/projects/ title=프로젝트><span style=font-weight:700>프로젝트</span></a></li><li><a href=https://cha2hyun.github.io/algorithm/ title=알고리즘><span style=font-weight:700>알고리즘</span></a></li><li><a href=https://cha2hyun.github.io/posts/ title=블로그><span style=font-weight:700>블로그</span></a></li><li><a href=https://cha2hyun.github.io/search/ title=검색><span style=font-weight:700>검색</span></a></li><li><a href=https://cha2hyun.github.io/tags/ title=태그><span style=font-weight:700>태그</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs></div><a href=https://cha2hyun.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cha2hyun.github.io/projects/>Projects</a></div><h1 class=post-title>Next.js 에서 무한스크롤 및 스크롤 위치 내용 저장하는 2가지 방법</h1><div class=post-meta><div class=views style=margin-right:8px><span class=views><img src="https://visitor-badge.glitch.me/badge?page_id=https%3a%2f%2fcha2hyun.github.io%2fprojects%2f%25ED%2581%2590%25EC%25B0%25BE%25EC%2582%25AC%2finfinitescroll%2f&left_color=gray&right_color=gray&left_text=Article Hits" alt=Views></span></div><span title='2022-11-04 00:00:00 +0000 UTC'>November 4, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;cha2hyun</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%eb%93%a4%ec%96%b4%ea%b0%80%eb%a9%b0 aria-label=들어가며>들어가며</a></li><li><a href=#%ec%a4%80%eb%b9%84%ed%95%98%eb%a9%b0 aria-label=준비하며>준비하며</a></li><li><a href=#%ec%83%81%ec%84%b8%ed%8e%98%ec%9d%b4%ec%a7%80-%ed%91%9c%ec%8b%9c-%ec%a0%84%eb%9e%b5 aria-label="상세페이지 표시 전략">상세페이지 표시 전략</a></li><li><a href=#%ea%b5%ac%ed%98%84 aria-label=구현>구현</a></li></ul></div></details></div><div class=post-content><h3 id=들어가며>들어가며<a hidden class=anchor aria-hidden=true href=#들어가며>#</a></h3><p>새로운 홈페이지를 기획, 개발하면서 최대한 <code>앱</code>과 동일한 사용자 경험을 주기 위해 고민을 많이 했습니다. 오랫동안 준비했던 <code>apppage_v2</code>의 경우 <code>react</code>로 제작하였으며 일반적인 페지네이션을 이용했습니다. 다만, 일반적인 페지네이션으로는 모바일에서 <code>앱</code>과 같은 경험을 주지 못하는 점이 아쉬워 아예 새롭게 <code>Next.js</code>로 프로젝트를 새로 만들어서 <code>React Query</code>의 <code>infiniteScroll</code>을 도입하였습니다.
<img loading=lazy src=./img/index/1.png alt=사진></p><h3 id=준비하며>준비하며<a hidden class=anchor aria-hidden=true href=#준비하며>#</a></h3><p>무한 스크롤을 도입할 때 다음과 같은 내용이 고려되었습니다.</p><ol><li>무한 스크롤이 적용된 리스트를 클릭했을때 어떤 식으로 상세페이지를 제공할 것인가?</li><li>상세페이지에서 다시 리스트로 돌아갈때 이미 불러온 데이터를 다시 불러오지 않아야한다.</li><li>2번이 적용된다면 다시 리스트로 돌아갈때 스크롤 했던 위치로 돌아가져야한다.</li></ol><h3 id=상세페이지-표시-전략>상세페이지 표시 전략<a hidden class=anchor aria-hidden=true href=#상세페이지-표시-전략>#</a></h3><p>무한 스크롤이 도입될 곳은 <code>내큐찾기</code>와 <code>커뮤니티</code> 였습니다. 다만 두 카테고리는 각자 다른 특성을 가지고 있습니다. 서비스 핵심 모델이 적요되는 <code>내큐찾기</code>에서는 최대한 빠르게 유저에게 로딩되는 경험을 주어야하고, <code>커뮤니티</code>에서는 댓글, 답글 등의 추가 기능들이 필요했습니다. 따라서 다음과 같이 적용하였습니다.</p><ul><li><p>내큐찾기</p><ul><li><code>List</code>에서 <code>Item</code> 클릭 시 Route 이동 없이 <code>Modal</code> 형식으로 제공</li><li><code>List</code>에서 <code>Fetch</code> 시 <code>Modal</code>에서 표시할 내용들은 전부 포함하도록 Api 설계</li><li>따라서 <code>Modal</code>에 들어갈때 추가 로딩표시 없이 <code>즉각적으로 보여지게됨</code></li><li>한번 Fetching한 데이터는 <code>캐시</code>에 남겨 로딩할 때도 매우빠른 로딩속도를 제공</li><li>각 <code>Item</code> 은 화면에 표시될 때 <code>Fade in 애니메이션</code>을 주어 새롭운 페이지를 Fetching 할때도 자연스럽고 연속적으로 보여지는 것으로 의도
<img loading=lazy src=./img/index/2.gif alt=결과></li></ul></li><li><p>커뮤니티</p><ul><li><code>List</code>에서 <code>Item</code> 클릭 시 <code>새로운 상세페이지</code>로 이동</li><li>이동할때 이때 <code>LocalStoarge</code>에 <code>scrollY</code> 값을 저장</li><li>상세페이지에서 다시 리스트로 돌아올 때 <code>scrollY 값으로 스크롤 위치 이동</code></li><li>단, 이때 처음부터 List를 다시 불러온다면 저장된 scrollY 값으로 가질 수 없으므로 (1번 이상 추가로딩이 되었을 경우) <code>리스트 데이터는 새로 불러오면 안된다</code>.
<img loading=lazy src=./img/index/3.gif alt=결과></li></ul></li></ul><h3 id=구현>구현<a hidden class=anchor aria-hidden=true href=#구현>#</a></h3><p>계속 &mldr;</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://cha2hyun.github.io/tags/next.js/>Next.js</a></li><li><a href=https://cha2hyun.github.io/tags/react-query/>React Query</a></li><li><a href=https://cha2hyun.github.io/tags/infinite-scroll/>Infinite Scroll</a></li></ul><div style=padding-top:15px;padding-bottom:2px;font-size:x-large;font-weight:700>Any Comments? 😀</div><div class=share-buttons></div><script src=https://utteranc.es/client.js repo=cha2hyun/blog-comments issue-term=title theme=boxy-light crossorigin=anonymous async></script></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://cha2hyun.github.io/>채수현 개발일지</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>